#pragma once

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>

#define SHA512_DIGEST_SIZE 64
#define SHA512_BLOCK_SIZE 128

#define LL_CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define LL_MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define LL_ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (64-(b))))
#define S0(a) (LL_ROTRIGHT(a, 28) ^ LL_ROTRIGHT(a, 34) ^ LL_ROTRIGHT(a, 39))
#define S1(e) (LL_ROTRIGHT(e, 14) ^ LL_ROTRIGHT(e, 18) ^ LL_ROTRIGHT(e, 41))
#define s0_sha(w) (LL_ROTRIGHT(w, 1) ^ LL_ROTRIGHT(w, 8) ^ (w >> 7))
#define s1_sha(w) (LL_ROTRIGHT(w, 19) ^ LL_ROTRIGHT(w, 61) ^ (w >> 6))

typedef unsigned char BYTE;
typedef uint64_t QWORD;

typedef struct {
    BYTE data[128];
    QWORD datalen;
    QWORD bitlen;
    QWORD state[8];
} SHA512_CTX;

__constant__ QWORD sha512_dev_k[80] = {
    0x428a2f98d728ae22,0x7137449123ef65cd,0xb5c0fbcfec4d3b2f,0xe9b5dba58189dbbc,0x3956c25bf348b538,
    0x59f111f1b605d019,0x923f82a4af194f9b,0xab1c5ed5da6d8118,0xd807aa98a3030242,0x12835b0145706fbe,
    0x243185be4ee4b28c,0x550c7dc3d5ffb4e2,0x72be5d74f27b896f,0x80deb1fe3b1696b1,0x9bdc06a725c71235,
    0xc19bf174cf692694,0xe49b69c19ef14ad2,0xefbe4786384f25e3,0x0fc19dc68b8cd5b5,0x240ca1cc77ac9c65,
    0x2de92c6f592b0275,0x4a7484aa6ea6e483,0x5cb0a9dcbd41fbd4,0x76f988da831153b5,0x983e5152ee66dfab,
    0xa831c66d2db43210,0xb00327c898fb213f,0xbf597fc7beef0ee4,0xc6e00bf33da88fc2,0xd5a79147930aa725,
    0x06ca6351e003826f,0x142929670a0e6e70,0x27b70a8546d22ffc,0x2e1b21385c26c926,0x4d2c6dfc5ac42aed,
    0x53380d139d95b3df,0x650a73548baf63de,0x766a0abb3c77b2a8,0x81c2c92e47edaee6,0x92722c851482353b,
    0xa2bfe8a14cf10364,0xa81a664bbc423001,0xc24b8b70d0f89791,0xc76c51a30654be30,0xd192e819d6ef5218,
    0xd69906245565a910,0xf40e35855771202a,0x106aa07032bbd1b8,0x19a4c116b8d2d0c8,0x1e376c085141ab53,
    0x2748774cdf8eeb99,0x34b0bcb5e19b48a8,0x391c0cb3c5c95a63,0x4ed8aa4ae3418acb,0x5b9cca4f7763e373,
    0x682e6ff3d6b2b8a3,0x748f82ee5defb2fc,0x78a5636f43172f60,0x84c87814a1f0ab72,0x8cc702081a6439ec,
    0x90befffa23631e28,0xa4506cebde82bde9,0xbef9a3f7b2c67915,0xc67178f2e372532b,0xca273eceea26619c,
    0xd186b8c721c0c207,0xeada7dd6cde0eb1e,0xf57d4f7fee6ed178,0x06f067aa72176fba,0x0a637dc5a2c898a6,
    0x113f9804bef90dae,0x1b710b35131c471b,0x28db77f523047d84,0x32caab7b40c72493,0x3c9ebe0a15c9bebc,
    0x431d67c49c100d4c,0x4cc5d4becb3e42b6,0x597f299cfc657e2a,0x5fcb6fab3ad6faec,0x6c44198c4a475817
};

__device__ inline void sha512_init(SHA512_CTX* ctx) {
    ctx->datalen = 0; ctx->bitlen = 0;
    ctx->state[0] = 0x6a09e667f3bcc908; ctx->state[1] = 0xbb67ae8584caa73b;
    ctx->state[2] = 0x3c6ef372fe94f82b; ctx->state[3] = 0xa54ff53a5f1d36f1;
    ctx->state[4] = 0x510e527fade682d1; ctx->state[5] = 0x9b05688c2b3e6c1f;
    ctx->state[6] = 0x1f83d9abfb41bd6b; ctx->state[7] = 0x5be0cd19137e2179;
}

__device__ inline void sha512_transform(SHA512_CTX* ctx, const BYTE data[]) {
    QWORD a, b, c, d, e, f, g, h, i, t1, t2, m[80];
    for (i = 0; i < 16; i++) m[i] = ((QWORD)data[i * 8] << 56) | ((QWORD)data[i * 8 + 1] << 48) | ((QWORD)data[i * 8 + 2] << 40) | ((QWORD)data[i * 8 + 3] << 32) | ((QWORD)data[i * 8 + 4] << 24) | ((QWORD)data[i * 8 + 5] << 16) | ((QWORD)data[i * 8 + 6] << 8) | ((QWORD)data[i * 8 + 7]);
    for (i = 16; i < 80; i++) m[i] = s1_sha(m[i - 2]) + m[i - 7] + s0_sha(m[i - 15]) + m[i - 16];
    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2]; d = ctx->state[3]; e = ctx->state[4]; f = ctx->state[5]; g = ctx->state[6]; h = ctx->state[7];
    for (i = 0; i < 80; i++) {
        t1 = h + S1(e) + LL_CH(e, f, g) + sha512_dev_k[i] + m[i];
        t2 = S0(a) + LL_MAJ(a, b, c);
        h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2;
    }
    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c; ctx->state[3] += d; ctx->state[4] += e; ctx->state[5] += f; ctx->state[6] += g; ctx->state[7] += h;
}

__device__ inline void sha512_update(SHA512_CTX* ctx, const BYTE data[], size_t len) {
    for (size_t i = 0; i < len; i++) {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;
        if (ctx->datalen == 128) {
            sha512_transform(ctx, ctx->data);
            ctx->bitlen += 1024;
            ctx->datalen = 0;
        }
    }
}

// Sha512_final function
__device__ inline void sha512_final(SHA512_CTX* ctx, BYTE hash[]) {
    QWORD i;
    i = ctx->datalen;
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[i++] = 0x80;
    if (ctx->datalen > 111) {
        while(i < 128) ctx->data[i++] = 0x00;
        sha512_transform(ctx, ctx->data);
        i = 0;
    }
    while(i < 112) ctx->data[i++] = 0x00;

    // Correctly create the 128-bit length from a 64-bit variable.
    // The upper 64 bits of the length are 0, as we don't support messages > 2^64 bits.
    ctx->data[112] = 0; ctx->data[113] = 0; ctx->data[114] = 0; ctx->data[115] = 0;
    ctx->data[116] = 0; ctx->data[117] = 0; ctx->data[118] = 0; ctx->data[119] = 0;
    // The lower 64 bits contain the actual length.
    ctx->data[120] = (ctx->bitlen >> 56) & 0xFF;
    ctx->data[121] = (ctx->bitlen >> 48) & 0xFF;
    ctx->data[122] = (ctx->bitlen >> 40) & 0xFF;
    ctx->data[123] = (ctx->bitlen >> 32) & 0xFF;
    ctx->data[124] = (ctx->bitlen >> 24) & 0xFF;
    ctx->data[125] = (ctx->bitlen >> 16) & 0xFF;
    ctx->data[126] = (ctx->bitlen >> 8) & 0xFF;
    ctx->data[127] = (ctx->bitlen >> 0) & 0xFF;

    sha512_transform(ctx, ctx->data);

    for (i = 0; i < 8; i++) {
        hash[i*8 + 0] = (ctx->state[i] >> 56) & 0xff; hash[i*8 + 1] = (ctx->state[i] >> 48) & 0xff;
        hash[i*8 + 2] = (ctx->state[i] >> 40) & 0xff; hash[i*8 + 3] = (ctx->state[i] >> 32) & 0xff;
        hash[i*8 + 4] = (ctx->state[i] >> 24) & 0xff; hash[i*8 + 5] = (ctx->state[i] >> 16) & 0xff;
        hash[i*8 + 6] = (ctx->state[i] >> 8) & 0xff;  hash[i*8 + 7] = (ctx->state[i] >> 0) & 0xff;
    }
}

// (iterative_sha512, md5_cuda, AES functions)
__device__ inline void iterative_sha512(const char* input, int length, char* hex_output, int iterations) {
    SHA512_CTX ctx;
    BYTE buffer[64];
    sha512_init(&ctx);
    sha512_update(&ctx, (const BYTE*)input, length);
    sha512_final(&ctx, buffer);
    for (int i = 1; i < iterations; i++) {
        sha512_init(&ctx);
        sha512_update(&ctx, buffer, 64);
        sha512_final(&ctx, buffer);
    }
    for (int i = 0; i < 64; i++) {
        unsigned char c = buffer[i];
        unsigned char high = (c >> 4) & 0xF;
        unsigned char low = c & 0xF;
        hex_output[2*i]   = (high < 10) ? ('0' + high) : ('a' + high - 10);
        hex_output[2*i+1] = (low  < 10) ? ('0' + low ) : ('a' + low  - 10);
    }
}

__device__ inline void md5_cuda(const uint8_t* input, size_t len, uint8_t* output) {
    uint32_t a0 = 0x67452301, b0 = 0xefcdab89, c0 = 0x98badcfe, d0 = 0x10325476;
    const uint32_t T[64] = {0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391};
    const int S[64] = {7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21};
    #define F(x, y, z) ((x & y) | (~x & z))
    #define G(x, y, z) ((x & z) | (y & ~z))
    #define H(x, y, z) (x ^ y ^ z)
    #define I(x, y, z) (y ^ (x | ~z))
    #define RL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
    size_t new_len = ((((len + 8) / 64) + 1) * 64) - 8;
    uint8_t msg[512];
    for(size_t i=0; i<len; ++i) msg[i] = input[i];
    msg[len] = 0x80;
    for(size_t i=len+1; i<new_len; ++i) msg[i] = 0;
    uint64_t bits = len * 8;
    for(int i=0; i<8; ++i) msg[new_len+i] = (bits >> (i*8)) & 0xFF;
    for(size_t offset=0; offset < new_len+8; offset+=64) {
        uint32_t M[16];
        for (int j=0; j<16; ++j) M[j] = ((uint32_t)msg[offset+j*4]) | ((uint32_t)msg[offset+j*4+1]<<8) | ((uint32_t)msg[offset+j*4+2]<<16) | ((uint32_t)msg[offset+j*4+3]<<24);
        uint32_t a=a0, b=b0, c=c0, d=d0;
        for(int i=0; i<64; ++i) {
            uint32_t f, g;
            if(i<16){f=F(b,c,d); g=i;} else if(i<32){f=G(b,c,d); g=(5*i+1)%16;} else if(i<48){f=H(b,c,d); g=(3*i+5)%16;} else{f=I(b,c,d); g=(7*i)%16;}
            uint32_t temp=d; d=c; c=b; b=b+RL(a+f+T[i]+M[g], S[i]); a=temp;
        }
        a0+=a; b0+=b; c0+=c; d0+=d;
    }
    for(int i=0; i<4; ++i) { output[i] = (a0 >> (i*8)) & 0xff; output[i+4] = (b0 >> (i*8)) & 0xff; output[i+8] = (c0 >> (i*8)) & 0xff; output[i+12] = (d0 >> (i*8)) & 0xff; }
    #undef F
    #undef G
    #undef H
    #undef I
    #undef RL
}

#define AES_BLOCKLEN 16
typedef uint8_t state_t[4][4];
__constant__ uint8_t aes_sbox[256] = {0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};
__constant__ uint8_t aes_rsbox[256] = {0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d};
__constant__ uint8_t aes_Rcon[255] = {0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8};
__device__ inline uint8_t xtime(uint8_t x) { return ((x << 1) ^ (((x >> 7) & 1) * 0x1b)); }
#define Multiply(x, y) (((y & 1) * x) ^ ((y>>1 & 1) * xtime(x)) ^ ((y>>2 & 1) * xtime(xtime(x))) ^ ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^ ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))
__device__ inline void InvMixColumns(state_t* state) { uint8_t a,b,c,d; for(int i=0;i<4;++i){a=(*state)[i][0];b=(*state)[i][1];c=(*state)[i][2];d=(*state)[i][3];(*state)[i][0]=Multiply(a,0x0e)^Multiply(b,0x0b)^Multiply(c,0x0d)^Multiply(d,0x09);(*state)[i][1]=Multiply(a,0x09)^Multiply(b,0x0e)^Multiply(c,0x0b)^Multiply(d,0x0d);(*state)[i][2]=Multiply(a,0x0d)^Multiply(b,0x09)^Multiply(c,0x0e)^Multiply(d,0x0b);(*state)[i][3]=Multiply(a,0x0b)^Multiply(b,0x0d)^Multiply(c,0x09)^Multiply(d,0x0e);}}
__device__ inline void InvSubBytes(state_t* state) { for (int i=0;i<4;++i) for (int j=0;j<4;++j) (*state)[j][i] = aes_rsbox[(*state)[j][i]]; }
__device__ inline void InvShiftRows(state_t* state) {uint8_t temp;temp=(*state)[3][1];(*state)[3][1]=(*state)[2][1];(*state)[2][1]=(*state)[1][1];(*state)[1][1]=(*state)[0][1];(*state)[0][1]=temp;temp=(*state)[0][2];(*state)[0][2]=(*state)[2][2];(*state)[2][2]=temp;temp=(*state)[1][2];(*state)[1][2]=(*state)[3][2];(*state)[3][2]=temp;temp=(*state)[0][3];(*state)[0][3]=(*state)[1][3];(*state)[1][3]=(*state)[2][3];(*state)[2][3]=(*state)[3][3];(*state)[3][3]=temp;}
__device__ inline void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey) { for (int i=0;i<4;++i) for (int j=0;j<4;++j) (*state)[i][j] ^= RoundKey[(round*AES_BLOCKLEN)+(i*4)+j]; }
__device__ inline void InvCipher(state_t* state, const uint8_t* RoundKey, uint8_t rounds) {AddRoundKey(rounds, state, RoundKey);for (int8_t round=rounds-1;;--round){InvShiftRows(state);InvSubBytes(state);AddRoundKey(round,state,RoundKey);if(round==0)break;InvMixColumns(state);}}
__device__ inline void XorWithIv(uint8_t* buf, const uint8_t* Iv) { for (int i=0;i<AES_BLOCKLEN;++i) buf[i] ^= Iv[i]; }
__device__ inline void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key, uint8_t rounds, uint8_t Nk) {unsigned i;unsigned Nb=4;unsigned ksWords=Nb*(rounds+1);uint32_t w[256];for(i=0;i<Nk;++i)w[i]=((uint32_t)Key[4*i]<<24)|((uint32_t)Key[4*i+1]<<16)|((uint32_t)Key[4*i+2]<<8)|((uint32_t)Key[4*i+3]);for(i=Nk;i<ksWords;++i){uint32_t temp=w[i-1];if(i%Nk==0){temp=(temp<<8)|(temp>>24);temp=((uint32_t)aes_sbox[(temp>>24)&0xff]<<24)|((uint32_t)aes_sbox[(temp>>16)&0xff]<<16)|((uint32_t)aes_sbox[(temp>>8)&0xff]<<8)|((uint32_t)aes_sbox[temp&0xff]);temp^=((uint32_t)aes_Rcon[i/Nk])<<24;}else if(Nk>6&&(i%Nk)==4)temp=((uint32_t)aes_sbox[(temp>>24)&0xff]<<24)|((uint32_t)aes_sbox[(temp>>16)&0xff]<<16)|((uint32_t)aes_sbox[(temp>>8)&0xff]<<8)|((uint32_t)aes_sbox[temp&0xff]);w[i]=w[i-Nk]^temp;}for(i=0;i<ksWords;++i){RoundKey[4*i+0]=(w[i]>>24)&0xff;RoundKey[4*i+1]=(w[i]>>16)&0xff;RoundKey[4*i+2]=(w[i]>>8)&0xff;RoundKey[4*i+3]=w[i]&0xff;}}